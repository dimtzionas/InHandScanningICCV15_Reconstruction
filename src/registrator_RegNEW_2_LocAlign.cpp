// Author: Dimitrios Tzionas
//
// source code for the work:
//
// Dimitrios Tzionas and Juergen Gall
// 3D Object Reconstruction from Hand-Object Interactions
// International Conference on Computer Vision (ICCV) 2015
// http://files.is.tue.mpg.de/dtzionas/In-Hand-Scanning


#include <registrator.h>

#include <stdio.h>
#include "opencv2/core/core.hpp"
#include "opencv2/nonfree/features2d.hpp"









////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////  LOCAL ALIGNMENT !!! //////////////////////////////////////////////////////////////////////////////////////////    LOCAL ALIGNMENT !!!
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





void Registrator::myReg_1_LocalAlign(    bool    TEST_MODE,
                                         QString INPUT_PATH,
                                         QString OUTPUT_PATH,
                                         int     NUMBBB,
                                         bool    VIEW_ENABLED,
                                         bool    FEAT_ENABLED,
                                         bool    ICP_ENABLED,
                                         QString input__IMG__PCL,
                                         int     offHand     )
{





    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    QString pathSave;
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    bool                                    FEAT_ENABLED_2d = FEAT_ENABLED && (PARAM_RUN_CorrWeight_OBJ_Feat2d>0);
    bool                                    FEAT_ENABLED_3d = FEAT_ENABLED && (PARAM_RUN_CorrWeight_OBJ_Feat3d>0);

    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    if (PARAM_RUN__ONLY__TOUCH__TRANSF)  {  FEAT_ENABLED_2d = false;
                                            FEAT_ENABLED_3d = false;
                                            FEAT_ENABLED    = false;  }
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    std::cout << INPUT_PATH.toStdString() << "\n"
                              << "NUMBBB               = " << NUMBBB                                << std::endl;
                    std::cout << "applyHANDs           = " << applyHANDs                            << "\n"
                              << "TEST_MODE            = " << TEST_MODE                             << std::endl;
                    std::cout << "offHand              = " << offHand                               << "\n\n"
                              << "FEAT_ENABLED         = " << FEAT_ENABLED                          << "\n"
                              << "FEAT_ENABLED_2d      = " << FEAT_ENABLED_2d                       << "\n"
                              << "FEAT_ENABLED_3d      = " << FEAT_ENABLED_3d                       << "\n"
                              << "ICP_ENABLED          = " << ICP_ENABLED                           << "\n\n"
                              << "input__IMG__PCL      = " << input__IMG__PCL.toStdString()         << std::endl;
                    std::cout << "syntheticORrealistic = " << syntheticORrealistic.toStdString()    << std::endl;
    //exit(1);
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (TEST_MODE == false)
    {

                                    if ( QDir(         QString(  OUTPUT_PATH                      )).exists() == false)
                                         QDir().mkdir( QString(  OUTPUT_PATH                      ));
                                    if ( QDir(         QString(  OUTPUT_PATH + "trans_locTransf/" )).exists() == false)
                                         QDir().mkdir( QString(  OUTPUT_PATH + "trans_locTransf/" ));


    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    pcl::PointCloud<TYPE_Point_Sensor>::Ptr source_cloud_ORGan_P_(       new pcl::PointCloud<TYPE_Point_Sensor>   );
    pcl::PointCloud<TYPE_Point_Sensor>::Ptr target_cloud_ORGan_P_(       new pcl::PointCloud<TYPE_Point_Sensor>   );
    pcl::PointCloud<TYPE_Point_PostPr>::Ptr source_cloud_UNorg_PN(       new pcl::PointCloud<TYPE_Point_PostPr>   );
    pcl::PointCloud<TYPE_Point_PostPr>::Ptr target_cloud_UNorg_PN(       new pcl::PointCloud<TYPE_Point_PostPr>   );
    pcl::PointCloud<TYPE_Point_KEYpt >::Ptr source_cloud_KEYp__3D(       new pcl::PointCloud<TYPE_Point_KEYpt>    );
    pcl::PointCloud<TYPE_Point_KEYpt >::Ptr target_cloud_KEYp__3D(       new pcl::PointCloud<TYPE_Point_KEYpt>    );
    pcl::PointCloud<TYPE_feature     >::Ptr source_cloud_FEAT__3D(       new pcl::PointCloud<TYPE_feature>        );
    pcl::PointCloud<TYPE_feature     >::Ptr target_cloud_FEAT__3D(       new pcl::PointCloud<TYPE_feature>        );
    pcl::PointCloud<TYPE_Point_PostPr>::Ptr accumAlignedClouds_UNorg_PN( new pcl::PointCloud<TYPE_Point_PostPr>   );

    double model_resolution_Source;
    double model_resolution_Target;

    SphereCoff source_Sphere_Coeff_XYZR; // center.x // center.y // center.z // radius
    SphereCoff target_Sphere_Coeff_XYZR;
    int        totalTouchFing_Source;
    int        totalTouchFing_Target;

    QVector<int> framesTouchProblem;
    //exit(1);


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer("3D Viewer"));
                                                         viewer->setBackgroundColor( PARAM_BackGround_RRR, PARAM_BackGround_GGG, PARAM_BackGround_BBB );
                 if (PARAM_DBG_addCoordinateSystem)      viewer->addCoordinateSystem(PARAM_DBG_addCoordinateSysSIZ);


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    QVector< Eigen::Matrix4f >                      finalCloudTransformations;
                                                    finalCloudTransformations.resize( NUMBBB );
    for (int listID=0; listID<NUMBBB; listID++)     finalCloudTransformations[ listID ] = Eigen::Matrix4f::Identity();

    QVector< Eigen::Matrix4f >                      finalCloudTransfUPDATEmat;
                                                    finalCloudTransfUPDATEmat.resize( NUMBBB );
    for (int listID=0; listID<NUMBBB; listID++)     finalCloudTransfUPDATEmat[ listID ] = Eigen::Matrix4f::Identity();


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    if (applyHANDs)     myLoadCameraParams( viewer );


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////// after initializing *finalCloudTransformations*
    /////////////////////////////////////////////////////////
    if (TEST_MODE == true)                        NUMBBB = 2;                                                   // OK
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    int ifENDDD_fileID = PARAM_INDEX_List.frames[ NUMBBB-1                       + PARAM_DBG_offfff ].fileID;   // OK
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    int ifSTART_fileID = PARAM_INDEX_List.frames[ 0         - PARAM_DBG_offInter + PARAM_DBG_offfff ].fileID;   // OK
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////


    std::cout << "\n\n"                                << std::endl;
    std::cout << "NUMBBB         = " << NUMBBB         << std::endl;
    std::cout << "ifENDDD_fileID = " << ifENDDD_fileID << std::endl;
    std::cout << "ifSTART_fileID = " << ifSTART_fileID << std::endl;
    std::cout << "\n\n"                                << std::endl;


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    for (int pairID=0; pairID<NUMBBB-1; pairID++)                                                               // OK
    {

            /////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////
            int sourceIndex = pairID + 1                      + PARAM_DBG_offfff;                               // OK
            int targetIndex = pairID + 0 - PARAM_DBG_offInter + PARAM_DBG_offfff;                               // OK
            /////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////
            int sourceID_fileID = PARAM_INDEX_List.frames[ sourceIndex ].fileID;    // Source = CURR            // OK
            int sourceID_listID = PARAM_INDEX_List.frames[ sourceIndex ].listID;    // Source = CURR            // OK
            int targetID_fileID = PARAM_INDEX_List.frames[ targetIndex ].fileID;    // TARGET = PREV            // OK
            int targetID_listID = PARAM_INDEX_List.frames[ targetIndex ].listID;    // TARGET = PREV            // OK
            /////////////////////////////////////////////////////////////////////
            int sourceID_pairID = PARAM_INDEX_List.frames[ sourceIndex ].pairID;
            int targetID_pairID = PARAM_INDEX_List.frames[ targetIndex ].pairID;
            /////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////
            if ( sourceID_fileID<0                             ||
                 sourceID_listID<0                             ||
                 targetID_fileID<0                             ||
                 targetID_listID<0                             ||
              //(sourceID_fileID>NUMBBB-1 && TEST_MODE==false) ||
                (sourceID_listID>NUMBBB-1 && TEST_MODE==false) ||
              //(targetID_fileID>NUMBBB-1 && TEST_MODE==false) ||
                (targetID_listID>NUMBBB-1 && TEST_MODE==false)  )
            {
                std::cout << "\n\n" << "Problem with ID value !!!" << "\n\n" << std::endl;
                std::cout << "sourceID_fileID = " << sourceID_fileID         << std::endl;
                std::cout << "sourceID_listID = " << sourceID_listID         << std::endl;
                std::cout << "targetID_fileID = " << targetID_fileID         << std::endl;
                std::cout << "targetID_listID = " << targetID_listID         << std::endl;
                std::cout << "sourceIndex     = " << sourceIndex             << std::endl;
                std::cout << "targetIndex     = " << targetIndex             << std::endl;
                exit(1);
            }
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////



            std::cout << "////////////////////////////////////////////////////////////////////"            << std::endl;
            std::cout << "////////////////////////////////////////// sourceIndex   - "   << sourceIndex    << std::endl;
            std::cout << "////////////////////////////////////////// targetIndex   - "   << targetIndex    << std::endl;
            std::cout << "////////////////////////////////////////////////////////////////////"            << std::endl;
            std::cout << "////////////////////////////////////////// Source fileID - " << sourceID_fileID  << std::endl;
            std::cout << "////////////////////////////////////////// Target fileID - " << targetID_fileID  << std::endl;
            std::cout << "////////////////////////////////////////////////////////////////////"            << std::endl;
            std::cout << "////////////////////////////////////////// Source pairID - " << sourceID_pairID  << std::endl;
            std::cout << "////////////////////////////////////////// Target pairID - " << targetID_pairID; if (sourceID_pairID==targetID_pairID) std::cout<<std::endl; else std::cout<<"  ~~~~~"<<std::endl;
            std::cout << "////////////////////////////////////////////////////////////////////"            << std::endl;
            std::cout <<                                                                                      std::endl;



            ////////////////////////////////////////////////////////////////////////////////////////////////////  it doesn't matter what **input__IMG__PCL** you have,
            ////////////////////////////////////////////////////////////////////////////////////////////////////  you need the 2d features !!!
            ////////////////////////////////////////////////////////////////////////////////////////////////////
            if (   (input__IMG__PCL == "IMG")                     ||
                   (input__IMG__PCL == "PCL" && FEAT_ENABLED_2d)   )
            {

                   readIMGs_getPCLs_getFEAT2D( sourceID_fileID,
                                               targetID_fileID,
                                               INPUT_PATH,
                                               OUTPUT_PATH,
                                               FEAT_ENABLED_2d,
                                               ifSTART_fileID,
                                               "local",
                                               source_cloud_ORGan_P_, // OUT
                                               target_cloud_ORGan_P_, // OUT
                                               corr_FEAT__2D,         // OUT
                                               false,
                                               false,
                                               true);

            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////


            if (input__IMG__PCL == "PCL")
            {

                    std::string                 fileName_source =  QString(   INPUT_PATH + "pcl/" + QString::number( sourceID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd"   ).toStdString();
                    std::string                 fileName_target =  QString(   INPUT_PATH + "pcl/" + QString::number( targetID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd"   ).toStdString();
                  //std::cout <<                                   std::endl;
                  //std::cout << "Source - " << fileName_source << std::endl;
                  //std::cout << "Target - " << fileName_target << std::endl;
                  //std::cout <<                                   std::endl;

                    pcl::io::loadPCDFile<TYPE_Point_Sensor>( fileName_target, *target_cloud_ORGan_P_ );
                    pcl::io::loadPCDFile<TYPE_Point_Sensor>( fileName_source, *source_cloud_ORGan_P_ );

            }
            else if (input__IMG__PCL == "IMG")
            {


                    //////////////////////////////////////////////////////
                    //////////////////////////////////////////////////////
                    potentialUnitChange_PCL_m2mm( target_cloud_ORGan_P_ );
                    potentialUnitChange_PCL_m2mm( source_cloud_ORGan_P_ );
                    //////////////////////////////////////////////////////
                    //////////////////////////////////////////////////////

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            resolution_bilateral_normals_outlierRemoval_passthrough_KEEP_ORG(   source_cloud_ORGan_P_,
                                                                                target_cloud_ORGan_P_,
                                                                                source_cloud_UNorg_PN,
                                                                                target_cloud_UNorg_PN,
                                                                                model_resolution_Source,
                                                                                model_resolution_Target,
                                                                                TEST_MODE );


                                                    //////////////////////////////////////////////////////
            if (targetID_fileID==ifSTART_fileID)    PARAM_VOXELFILTER_leafSize += model_resolution_Target; // will be normalized in the end
                                                    PARAM_VOXELFILTER_leafSize += model_resolution_Source;
                                                    //////////////////////////////////////////////////////


            //std::cout << "model_resolution_Source" << "\t" << model_resolution_Source << std::endl;
            //std::cout << "model_resolution_Target" << "\t" << model_resolution_Target << std::endl << std::endl;

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        FEAT2D on BilteraledPCL
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////
            // target_cloud_UNorg_PN is still ORG here !!! //
            // source_cloud_UNorg_PN is still ORG here !!! //
            /////////////////////////////////////////////////


            if (FEAT_ENABLED_2d)
            {

                //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  FEAT2D on PCL " << std::endl << std::endl;

                refineTextureCORRs_withPostProccessedPCL( source_cloud_UNorg_PN,
                                                          target_cloud_UNorg_PN, corr_FEAT__2D, TEST_MODE, PARAM_OBJ_Mode__p2p_OR_p2plane );
            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Clean NAN Normals
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  ORG -> UNorg " << std::endl << std::endl;


            kickOut_pointsWith_CoordNAN_NormalNAN( target_cloud_UNorg_PN );
            kickOut_pointsWith_CoordNAN_NormalNAN( source_cloud_UNorg_PN );

            ////////////////////////////////////////////
            // target_cloud_UNorg_PN is UNORG now !!! //
            // source_cloud_UNorg_PN is UNORG now !!! //
            ////////////////////////////////////////////


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        TOUCH
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (applyHANDs)
            {

                        //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  Touch Detection " << std::endl << std::endl;


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        ////  ApplyMotionData  //////////////////////////////////////////////////////////////////////////////////////////////////
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        sequence->updateFrameNumber( sourceID_fileID+offHand, targetID_fileID+offHand );
                        sequence->transform_All_Model_MESHES( PARAM_DBG_ColorrMesh_Source__prAnim0_Mdel1 ); // resets RGB before touch detection
                        sequence->transform_All_Model_SKELETONS();

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        ////  Detect TOUCH & CORRESP  ///////////////////////////////////////////////////////////////////////////////////////////
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        // animNumb = 0 --> Source
                        // animNumb = 1 --> Target

                        if (PARAM_RUN_CorrWeight_SKIN>0)
                        {

                                {

                                        pcl::search::KdTree<pcl::PointXYZRGBNormal> tree_PCL_Source;
                                                                                    tree_PCL_Source.setInputCloud( source_cloud_UNorg_PN );
                                        pcl::search::KdTree<pcl::PointXYZRGBNormal> tree_PCL_Target;
                                                                                    tree_PCL_Target.setInputCloud( target_cloud_UNorg_PN );


                                        totalTouchFing_Source = touch->detector_SkinTouch( 0, tree_PCL_Source, touch->PARAM_should_ONLY_EF, false );    //std::cout << "SKIN     - totalTouchFing_Source - " << totalTouchFing_Source << "\t\t" << touch->PARAM_SKIN_Dist_THRESH_CURR << "\t\t" << touch->skinTouch_printTouchingFingers().toStdString() << std::endl;
                                        totalTouchFing_Target = touch->detector_SkinTouch( 1, tree_PCL_Target, touch->PARAM_should_ONLY_EF, false );    //std::cout << "SKIN     - totalTouchFing_Target - " << totalTouchFing_Target << "\t\t" << touch->PARAM_SKIN_Dist_THRESH_CURR << "\t\t" << touch->skinTouch_printTouchingFingers().toStdString() << std::endl;

                                }


                                if (touch->PARAM_TOUCH_Mode__intersection_OR_union_OR_full == "full")
                                {
                                    touch->detector_SkinTouch_ExpandTouchingBones_at_FULL_BONE();
                                }


                                if      (touch->PARAM_TOUCH_Mode__intersection_OR_union_OR_full == "intersection")  touch->correspondencesFinder_SKIN_intersection();
                                else if (touch->PARAM_TOUCH_Mode__intersection_OR_union_OR_full == "union"       )  touch->correspondencesFinder_SKIN_union();
                                else                                                             /*"full"*/         touch->correspondencesFinder_SKIN_full();


                                if (!touch->correspondencesFinder_SKIN_ENSURE_2_FINGs())
                                {
                                    std::cout << "\n\n" << "touch->correspondencesFinder_SKIN_ENSURE_2_FINGs() - PROBLEM !!!" << "\n\n" << std::endl;
                                    if (touch->PARAM_SKIN_ENFORCE_MIN_TouchFING_2_EXIT && TEST_MODE==false)  exit(1);
                                }

                                if (totalTouchFing_Target < touch->PARAM_SKIN_minTouchingFINGs)   {   framesTouchProblem.append( targetID_fileID );   std::cout << "\n\n" << "totalTouchFing_Target = "<<totalTouchFing_Target << " ONLYYYYY !!!" << "\n" << std::endl;   exit(1);   }
                                if (totalTouchFing_Source < touch->PARAM_SKIN_minTouchingFINGs)   {   framesTouchProblem.append( sourceID_fileID );   std::cout << "\n\n" << "totalTouchFing_Source = "<<totalTouchFing_Source << " ONLYYYYY !!!" << "\n" << std::endl;   exit(1);   }
                        }

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        KEYPOINTS
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (FEAT_ENABLED_3d)
            {

                    //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  KEYp 3D" << std::endl;

                    //                                  cloud_IN        model_ResolutionIN                    KEYpt_OUT
                    my_KeyPoint_Detector_ISS3D(  target_cloud_UNorg_PN, model_resolution_Target, target_cloud_KEYp__3D );
                    my_KeyPoint_Detector_ISS3D(  source_cloud_UNorg_PN, model_resolution_Source, source_cloud_KEYp__3D );


                    //std::cout <<                                                                             std::endl;
                    //std::cout << "      !!!! source_keypts      " << source_cloud_KEYp__3D->points.size() << std::endl;
                    //std::cout << "      !!!! target_keypts      " << target_cloud_KEYp__3D->points.size() << std::endl;
                    //std::cout <<                                                                             std::endl;

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        FEAT__3D
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (FEAT_ENABLED_3d)
            {

                    //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  FEAT 3D" << std::endl;

                    //                                        searchSurface           inputNormals               KEYpt     model_resolution                      FEAT__3D_OUT
                    my_Feature_Descriptor_on_ISS3D(   target_cloud_UNorg_PN, target_cloud_UNorg_PN, target_cloud_KEYp__3D, model_resolution_Target, target_cloud_FEAT__3D );
                    my_Feature_Descriptor_on_ISS3D(   source_cloud_UNorg_PN, source_cloud_UNorg_PN, source_cloud_KEYp__3D, model_resolution_Source, source_cloud_FEAT__3D );


                    //std::cout <<                                                                                     std::endl;
                    //std::cout << "      !!!! source_cloud_FEAT__3D      " << source_cloud_FEAT__3D->points.size() << std::endl;
                    //std::cout << "      !!!! target_cloud_FEAT__3D      " << target_cloud_FEAT__3D->points.size() << std::endl;
                    //std::cout <<                                                                                     std::endl;

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Intitial Tranformation
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                pcl::transformPointCloudWithNormals( *source_cloud_UNorg_PN, ///////////////////////////////////////////////
                                                                                     *source_cloud_UNorg_PN, finalCloudTransformations[ targetID_listID ] );
                                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                pcl::transformPointCloudWithNormals( *target_cloud_UNorg_PN, ///////////////////////////////////////////////
                                                                                     *target_cloud_UNorg_PN, finalCloudTransformations[ targetID_listID ] );
                                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                pcl::transformPointCloudWithNormals( *source_cloud_KEYp__3D, ///////////////////////////////////////////////
                                                                                     *source_cloud_KEYp__3D, finalCloudTransformations[ targetID_listID ] );   // BOTH OF THEM !!!
                                                pcl::transformPointCloudWithNormals( *target_cloud_KEYp__3D, ///////////////////////////////////////////////
                                                                                     *target_cloud_KEYp__3D, finalCloudTransformations[ targetID_listID ] );   // BOTH OF THEM !!!
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (applyHANDs)                     touch->TouchCorrespSKIN_TRASNFORM_Source(                    finalCloudTransformations[ targetID_listID ] );   // BOTH OF THEM !!!
            if (applyHANDs)                     touch->TouchCorrespSKIN_TRASNFORM_Target(                    finalCloudTransformations[ targetID_listID ] );   // BOTH OF THEM !!!
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (applyHANDs)                     touch->TouchingVertices_TRASNFORM_Source(                    finalCloudTransformations[ targetID_listID ] );   // animID 0 - source
            if (applyHANDs)                     touch->TouchingVertices_TRASNFORM_Target(                    finalCloudTransformations[ targetID_listID ] );   // animID 1 - target
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (FEAT_ENABLED_2d)                        texture3Dpoints_TRANSFORM_Source(                    finalCloudTransformations[ targetID_listID ] );   // animID 0 - source
            if (FEAT_ENABLED_2d)                        texture3Dpoints_TRANSFORM_Target(                    finalCloudTransformations[ targetID_listID ] );   // animID 1 - target
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        CORR EST
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (FEAT_ENABLED_3d)
            {

                    //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  Corresp Rejection 3D" << std::endl;


                    my_Correspondence_Estimation(  source_cloud_FEAT__3D,
                                                   target_cloud_FEAT__3D,
                                                   source_cloud_KEYp__3D,
                                                   target_cloud_KEYp__3D,
                                                           corr_FEAT__3D  );  // OUT

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        CORR FILTERING REJ common 2d 3d
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        CORR FUSION
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            pcl::PointCloud<TYPE_Point_KEYpt >::Ptr source_cloud_KEYfused(       new pcl::PointCloud<TYPE_Point_KEYpt>    );        source_cloud_KEYfused->  clear();
            pcl::PointCloud<TYPE_Point_KEYpt >::Ptr target_cloud_KEYfused(       new pcl::PointCloud<TYPE_Point_KEYpt>    );        target_cloud_KEYfused->  clear();
            pcl::CorrespondencesPtr                 corrFUSED_Filt(              new pcl::Correspondences                 );        corrFUSED_Filt->         clear();
            QVector<FUSED_CORRR_label>              corrFUSED_NonFilt_labels;                                                       corrFUSED_NonFilt_labels.clear();


                                ///////////////////
                                int KEYfusedID = 0;
                                ///////////////////


                                                                                                                    FUSE_CORRESPONDENCES(     source_cloud_KEYfused,
                                                                                                                                              target_cloud_KEYfused,
                                                                                                                                              corrFUSED_Filt,
                                                                                                                                              corrFUSED_NonFilt_labels,
                                                                                                                                              PARAM_RUN_CorrWeight_OBJ_Feat2d,
                                                                                                                                              PARAM_RUN_CorrWeight_OBJ_Feat3d,
                                                                                                                                           0/*PARAM_RUN_CorrWeight_SKIN*/,
                                                                                                                                              TEST_MODE,
                                                                                                                                              KEYfusedID,
                                                                                                                                              PARAM_RUN__ONLY__TOUCH__TRANSF);
                                ////////////////////////////////////////////////////////////////////////////////
                                ////////////////////////////////////////////////////////////////////////////////
                                ////////////////////////////////////////////////////////////////////////////////
                                my_Correspondence_Filtering_n_Rejection(   source_cloud_KEYfused,
                                                                           target_cloud_KEYfused,
                                                                           PARAM_CORR_REJ_InlierThreshold_LOCAL,
                                                                           PARAM_CORR_REJ_Kick_1_to_1,
                                                                           corrFUSED_Filt           );  // OUT
                                ////////////////////////////////////////////////////////////////////////////////
                                ////////////////////////////////////////////////////////////////////////////////
                                ////////////////////////////////////////////////////////////////////////////////

                                if (sourceID_pairID==targetID_pairID)      {                                        FUSE_CORRESPONDENCES(     source_cloud_KEYfused,
                                                                                                                                              target_cloud_KEYfused,
                                                                                                                                              corrFUSED_Filt,
                                                                                                                                              corrFUSED_NonFilt_labels,
                                                                                                                                           0/*PARAM_RUN_CorrWeight_OBJ_Feat2d*/,
                                                                                                                                           0/*PARAM_RUN_CorrWeight_OBJ_Feat3d*/,
                                                                                                                                              PARAM_RUN_CorrWeight_SKIN,
                                                                                                                                              TEST_MODE,
                                                                                                                                              KEYfusedID,
                                                                                                                                              PARAM_RUN__ONLY__TOUCH__TRANSF);

                                }
                                //else // if (sourceID_pairID!=targetID_pairID) // ignore TOUCH !!!   don't pay much attention to this comment, it's used for ctrl+F reasons


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        CORR SUMMARY
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            //////////////////////////
            int COUNT_CORR_Feat2D = 0;
            int COUNT_CORR_Feat3D = 0;
            int COUNT_CORR_Touch  = 0;
            //////////////////////////


            for (int ccc=0; ccc<corrFUSED_Filt->size(); ccc++)
            {
                int labelINDEX = (*corrFUSED_Filt)[ccc].index_query;
              //int labelINDE2 = (*corrFUSED_Filt)[ccc].index_match;

                int label = corrFUSED_NonFilt_labels[ labelINDEX ].label_ID;

                if      (label == 1)    COUNT_CORR_Touch++;
                else if (label == 2)    COUNT_CORR_Feat2D++;
                else if (label == 3)    COUNT_CORR_Feat3D++;
            }


            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          //                                                                                    std::cout <<                                                                       std::endl;
          //                                                                                    std::cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" <<                                 std::endl;
          //if (FEAT_ENABLED_2d)                                                                std::cout << "Correspondences Texture   " << corr_FEAT__2D.size()               << std::endl;
          //if (FEAT_ENABLED_3d)                                                                std::cout << "Correspondances Geometry  " << corr_FEAT__3D.size()               << std::endl;
          //if (applyHANDs && PARAM_RUN_CorrWeight_SKIN>0 && sourceID_pairID==targetID_pairID)  std::cout << "Correspondences Contact   " << touch->myTouchCorrespSKIN.size()   << std::endl;
                                                                                                std::cout <<                                                                       std::endl;
                                                                                                std::cout << "Correspondences Texture   " << COUNT_CORR_Feat2D                  << std::endl;
                                                                                                std::cout << "Correspondances Geometry  " << COUNT_CORR_Feat3D                  << std::endl;
                                                                                                std::cout << "Correspondences Contact   " << COUNT_CORR_Touch                   << std::endl;
                                                                                                std::cout << "Correspondences TOTAL     " << corrFUSED_Filt->size()             << std::endl;
                                                                                              //std::cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" <<                                 std::endl;
                                                                                                std::cout <<                                                                       std::endl;
            if (TEST_MODE)
            {
            std::cout << "@@@@  PARAM_DBG_Apply_Transf_Obj_Feat2d  " << PARAM_DBG_Apply_Transf_Obj_Feat2d                                                                       << std::endl;
            std::cout << "@@@@  PARAM_DBG_Apply_Transf_Obj_Feat3d  " << PARAM_DBG_Apply_Transf_Obj_Feat3d                                                                       << std::endl;
            std::cout << "@@@@  PARAM_DBG_Apply_Transf_Skin        " << PARAM_DBG_Apply_Transf_Skin                                                                             << std::endl;
            std::cout << "@@@@  PARAM_DBG_Apply_Transf_ICP         " << PARAM_DBG_Apply_Transf_ICP                                                                              << std::endl;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        ESTIMATE TRANSF
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            QString MODE_CORR_FINDER = "";


            ///////////////////////////////////////////////////////////////////
            Eigen::Matrix4f coarseTransformation = Eigen::Matrix4f::Identity();
            ///////////////////////////////////////////////////////////////////


            if (corrFUSED_Filt->size() >= 4)
            {


                    if (PARAM_OBJ_Mode__p2p_OR_p2plane == "p2p")
                    {


                          //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  FEAT - p2p" << std::endl;
                            MODE_CORR_FINDER =                                                                                     "p2p";


                            coarseTransformation = myTransformationEstimationPointToPointWeighted( source_cloud_KEYfused,
                                                                                                   target_cloud_KEYfused,
                                                                                                   corrFUSED_Filt );


                    }
                    else if (PARAM_OBJ_Mode__p2p_OR_p2plane == "p2plane"  ||
                             PARAM_OBJ_Mode__p2p_OR_p2plane == "p2planeW"  )
                    {


                          //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  FEAT - p2plane(W)" << std::endl;
                            MODE_CORR_FINDER =                                                                                     "p2plane(W)";

                            pcl::registration::TransformationEstimationPointToPlaneWeighted< TYPE_Point_KEYpt, TYPE_Point_KEYpt > transEstALL;
                            transEstALL.estimateRigidTransformation(        *source_cloud_KEYfused,  // IN
                                                                            *target_cloud_KEYfused,  // IN
                                                                            *corrFUSED_Filt,         // IN
                                                                             coarseTransformation ); // OUT


                    }


            } // if (corrFUSED_Filt->size() >= 4)


            //std::cout << "\n\n" << "coarseTransformation" << "\n" << coarseTransformation << "\n" << std::endl;


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (   (TEST_MODE==false && ( FEAT_ENABLED || applyHANDs) )     ||
                   (TEST_MODE==true  && ( PARAM_DBG_Apply_Transf_Obj_Feat2d ||
                                          PARAM_DBG_Apply_Transf_Obj_Feat3d ||
                                          PARAM_DBG_Apply_Transf_Skin        )   )   )
            {

                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    pcl::transformPointCloudWithNormals( *source_cloud_UNorg_PN, *source_cloud_UNorg_PN, coarseTransformation );
                    pcl::transformPointCloudWithNormals( *source_cloud_KEYp__3D, *source_cloud_KEYp__3D, coarseTransformation );
                    pcl::transformPointCloudWithNormals( *source_cloud_KEYfused, *source_cloud_KEYfused, coarseTransformation );
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if (FEAT_ENABLED)         texture3Dpoints_TRANSFORM_Source(                          coarseTransformation );
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if (applyHANDs)   touch->TouchingVertices_TRASNFORM_Source(                          coarseTransformation );   // animID 0 - source
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        ICP
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            Eigen::Matrix4f fineTransformation  = Eigen::Matrix4f::Identity();


            if (ICP_ENABLED)
            {

                    double                                      PARAM_RansacOutlierRejectionThreshold = 0;
                    if    (sourceID_pairID==targetID_pairID)    PARAM_RansacOutlierRejectionThreshold = PARAM_ICP_RansacOutlierRejectionThreshold;
                    else /*sourceID_pairID!=targetID_pairID*/   PARAM_RansacOutlierRejectionThreshold = PARAM_ICP_RansacOutlierRej__TRANSITION;
                    double                                      PARAM_TransformationEpsilon           = PARAM_ICP_TransformationEpsilon;
                    double                                      PARAM_EuclideanFitnessEpsilon         = PARAM_ICP_EuclideanFitnessEpsilon;
                    int                                         PARAM_MAX_ITER                        = PARAM_ICP_MAX_ITER;

                    QString                                     ICP_Mode__p2p_OR_p2plane;
                    if    (sourceID_pairID==targetID_pairID)    ICP_Mode__p2p_OR_p2plane = PARAM_ICP_Mode__p2p_OR_p2plane;
                    else /*sourceID_pairID!=targetID_pairID*/   ICP_Mode__p2p_OR_p2plane = PARAM_ICP_Mode__p2p_OR_p2plane_TRANSITION;


                    //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  ICP  - " << ICP_Mode__p2p_OR_p2plane.toStdString() << "   " << PARAM_RansacOutlierRejectionThreshold << "   " << PARAM_ICP_Mode__previous_OR_metascan.toStdString() << std::endl;


                    pcl::PointCloud<TYPE_Point_PostPr>::Ptr                        TMPaccumAlignedClouds_UNorg_PN( new pcl::PointCloud<TYPE_Point_PostPr> );
                    if (PARAM_ICP_Mode__previous_OR_metascan == "metascan")   {

                           double leafSize  = PARAM_VOXELFILTER_leafSize / (double)sourceID_listID;
                                  leafSize *= PARAM_VOXELFILTER_leafSizeCOEFF;
                           pcl::VoxelGrid< TYPE_Point_PostPr> voxelFilter;
                           voxelFilter.setInputCloud(     accumAlignedClouds_UNorg_PN    );
                           voxelFilter.setLeafSize(       leafSize, leafSize, leafSize   );
                           voxelFilter.filter(           *TMPaccumAlignedClouds_UNorg_PN );

                           if      (ICP_Mode__p2p_OR_p2plane == "p2p")        {    fineTransformation = My_ICP_Refinement___p2p(      source_cloud_UNorg_PN, TMPaccumAlignedClouds_UNorg_PN, PARAM_RansacOutlierRejectionThreshold, PARAM_TransformationEpsilon, PARAM_EuclideanFitnessEpsilon, PARAM_MAX_ITER );   }   // SHIFT3D/ISS3D
                           else if (ICP_Mode__p2p_OR_p2plane == "p2plane")    {    fineTransformation = My_ICP_Refinement___p2plane(  source_cloud_UNorg_PN, TMPaccumAlignedClouds_UNorg_PN, PARAM_RansacOutlierRejectionThreshold, PARAM_TransformationEpsilon, PARAM_EuclideanFitnessEpsilon, PARAM_MAX_ITER );   }   // SHIFT3D/ISS3D
                           else if (ICP_Mode__p2p_OR_p2plane == "p2planeW")   {    fineTransformation = My_ICP_Refinement___p2planeW( source_cloud_UNorg_PN, TMPaccumAlignedClouds_UNorg_PN, PARAM_RansacOutlierRejectionThreshold, PARAM_TransformationEpsilon, PARAM_EuclideanFitnessEpsilon, PARAM_MAX_ITER );   }
                    }
                    else  {                                   /*"previous"*/

                           if      (ICP_Mode__p2p_OR_p2plane == "p2p")        {    fineTransformation = My_ICP_Refinement___p2p(      source_cloud_UNorg_PN, target_cloud_UNorg_PN,          PARAM_RansacOutlierRejectionThreshold, PARAM_TransformationEpsilon, PARAM_EuclideanFitnessEpsilon, PARAM_MAX_ITER );   }   // SHIFT3D/ISS3D
                           else if (ICP_Mode__p2p_OR_p2plane == "p2plane")    {    fineTransformation = My_ICP_Refinement___p2plane(  source_cloud_UNorg_PN, target_cloud_UNorg_PN,          PARAM_RansacOutlierRejectionThreshold, PARAM_TransformationEpsilon, PARAM_EuclideanFitnessEpsilon, PARAM_MAX_ITER );   }   // SHIFT3D/ISS3D
                           else if (ICP_Mode__p2p_OR_p2plane == "p2planeW")   {    fineTransformation = My_ICP_Refinement___p2planeW( source_cloud_UNorg_PN, target_cloud_UNorg_PN,          PARAM_RansacOutlierRejectionThreshold, PARAM_TransformationEpsilon, PARAM_EuclideanFitnessEpsilon, PARAM_MAX_ITER );   }   // SHIFT3D/ISS3D
                    }
                    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                    if (   (TEST_MODE==false && ICP_ENABLED)                                ||
                           (TEST_MODE==true  && ICP_ENABLED && PARAM_DBG_Apply_Transf_ICP)   )
                    {

                        //////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////
                        pcl::transformPointCloudWithNormals( *source_cloud_UNorg_PN, *source_cloud_UNorg_PN, fineTransformation );
                        pcl::transformPointCloudWithNormals( *source_cloud_KEYp__3D, *source_cloud_KEYp__3D, fineTransformation );
                        pcl::transformPointCloudWithNormals( *source_cloud_KEYfused, *source_cloud_KEYfused, fineTransformation );
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////
                        if (applyHANDs)   touch->TouchingVertices_TRASNFORM_Source(                          fineTransformation );   // animID 0 - source
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////
                        if (FEAT_ENABLED)         texture3Dpoints_TRANSFORM_Source(                          fineTransformation );
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //////////////////////////////////////////////////////////////////////////////////////////////////////////

                        //std::cout << "\n" << fineTransformation << "\n" << std::endl;
                    }

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Final Update
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  Final Update" << std::endl;


            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            Eigen::Matrix4f                                finalUpdateMat = fineTransformation * coarseTransformation;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            finalCloudTransformations[ sourceID_listID ] = finalUpdateMat * finalCloudTransformations[ targetID_listID ];
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            finalCloudTransfUPDATEmat[ sourceID_listID ] = finalUpdateMat;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        SAVE ~~~
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (TEST_MODE == false)
            {

                    if (targetID_fileID==ifSTART_fileID)    {    pathSave = OUTPUT_PATH + "trans_locTransf/" + QString::number( targetID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".transf";                transf_2_txt(  finalCloudTransformations[ targetID_listID ], pathSave );  }
                                                            {    pathSave = OUTPUT_PATH + "trans_locTransf/" + QString::number( sourceID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".transf";                transf_2_txt(  finalCloudTransformations[ sourceID_listID ], pathSave );  }

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        PCLVisualizer ~~~ LIVE
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            ///////////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////////
            if (targetID_fileID==ifSTART_fileID)    *accumAlignedClouds_UNorg_PN += *target_cloud_UNorg_PN;
                                                    *accumAlignedClouds_UNorg_PN += *source_cloud_UNorg_PN;
            ///////////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////////


            ///////////////////////
            if (TEST_MODE == false)
            {  ////////////////////


                        //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  PCLVisualizer - addPointCloud" << std::endl;

                        if (targetID_fileID==ifSTART_fileID)  {
                        pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_PostPr>visColorTarget( target_cloud_UNorg_PN);
                        viewer->addPointCloud<TYPE_Point_PostPr>(                                            target_cloud_UNorg_PN, visColorTarget, QString(QString("target_cloud_UNorg_PN_")+QString::number(targetID_listID)).toStdString() );
                        viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,                                   QString(QString("target_cloud_UNorg_PN_")+QString::number(targetID_listID)).toStdString() );
                        }
                        pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_PostPr>visColorSource( source_cloud_UNorg_PN);
                        viewer->addPointCloud<TYPE_Point_PostPr>(                                            source_cloud_UNorg_PN, visColorSource, QString(QString("source_cloud_UNorg_PN_")+QString::number(sourceID_listID)).toStdString() );
                        viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,                                   QString(QString("source_cloud_UNorg_PN_")+QString::number(sourceID_listID)).toStdString() );
                        //////////////////////
                        viewer->resetCamera();
                        viewer->spinOnce();
                        //////////////////////

            }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////  Render DBG  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Render DBG
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                        if (TEST_MODE && PARAM_DBG_RenderCORR_Obj_FakeTransf)
                                                        {
                                                                Eigen::Matrix4f transf;
                                                                                transf << 1,0,0,PARAM_DBG_offx, // ONLY TRANSLATION !!!
                                                                                          0,1,0,PARAM_DBG_offy, // ONLY TRANSLATION !!!
                                                                                          0,0,1,PARAM_DBG_offz, // ONLY TRANSLATION !!!
                                                                                          0,0,0,1;              // ONLY TRANSLATION !!!

                                                                Eigen::Affine3f transf_(transf); // O.K. // transf_.matrix() == transf

                                                                pcl::transformPointCloud(            *source_cloud_ORGan_P_,
                                                                                                     *source_cloud_ORGan_P_, transf );
                                                                pcl::transformPointCloudWithNormals( *source_cloud_UNorg_PN,
                                                                                                     *source_cloud_UNorg_PN, transf );
                                                                if (FEAT_ENABLED_3d)
                                                                {
                                                                pcl::transformPointCloudWithNormals( *source_cloud_KEYp__3D,
                                                                                                     *source_cloud_KEYp__3D, transf );
                                                                }

                                                                pcl::transformPointCloudWithNormals( *source_cloud_KEYfused,
                                                                                                     *source_cloud_KEYfused, transf );


                                                                if (FEAT_ENABLED_2d)      texture3Dpoints_TRANSFORM_Source( transf );
                                                                if (applyHANDs)   touch->TouchingVertices_TRASNFORM_Source( transf );
                                                                if (applyHANDs)   touch->TouchCorrespSKIN_TRASNFORM_Source( transf );
                                                                if (applyHANDs)
                                                                {                                           // animNumb== 0 --> Source
                                                                        ModelSet* pModelSet = &(sequence->posedAnimations[0].modelSet);

                                                                        for (int modelID=0; modelID<pModelSet->models.size(); modelID++)
                                                                        {
                                                                                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                Model                       *pModel            = &(sequence->posedAnimations[0].modelSet.models[modelID]);
                                                                                SkinningBonesSkeletonStruct *pSkinningSkeleton = &(sequence->posedAnimations[0].modelSet.models[modelID].skinningSkeleton);
                                                                                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                                                for (int skkk=0; skkk<pModel->totalSkinningBones; skkk++)
                                                                                {
                                                                                    pSkinningSkeleton->skinningBones[skkk].bone_Start_PclPointXYZ = pcl::transformPoint( pSkinningSkeleton->skinningBones[skkk].bone_Start_PclPointXYZ, transf_ );
                                                                                    pSkinningSkeleton->skinningBones[skkk].bone_Leaff_PclPointXYZ = pcl::transformPoint( pSkinningSkeleton->skinningBones[skkk].bone_Leaff_PclPointXYZ, transf_ );
                                                                                }


                                                                                pcl::transformPointCloudWithNormals( *pModel->PCL,
                                                                                                                     *pModel->PCL, transf );
                                                                        }

                                                                        source_Sphere_Coeff_XYZR.center_PointXYZ = pcl::transformPoint( source_Sphere_Coeff_XYZR.center_PointXYZ, transf_ );
                                                                }

                                                                qDebug() << "\n\n\n"
                                                                         <<  INPUT_PATH                           << "\t\t"
                                                                         <<  syntheticORrealistic                 << "\n"
                                                                         << "PARAM_DBG_offx = " << PARAM_DBG_offx << "\n"
                                                                         << "PARAM_DBG_offy = " << PARAM_DBG_offy << "\n"
                                                                         << "PARAM_DBG_offz = " << PARAM_DBG_offz << "\n\n";
                                                        }


            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////  Render Skeletons / Touch CORR / Primitives  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Render Skeletons / Touch CORR / Primitives
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            float RRR;
            float GGG;
            float BBB;


            if (applyHANDs && TEST_MODE)
            {

                    if (PARAM_DBG_RenderSkeleton_Source)     renderer->renderSkeletons( viewer, 0 );  //animNumb = 0 --> Source
                    if (PARAM_DBG_RenderSkeleton_Target)     renderer->renderSkeletons( viewer, 1 );  //animNumb = 1 --> Target


                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                    if (PARAM_DBG_OverloadPCL_Source_ALL||PARAM_DBG_OverloadPCL_Source_HandsNonOccl||
                        PARAM_DBG_OverloadPCL_Target_ALL||PARAM_DBG_OverloadPCL_Target_HandsNonOccl )
                    {

                            bool source_FLAG = (PARAM_DBG_OverloadPCL_Source_ALL||PARAM_DBG_OverloadPCL_Source_HandsNonOccl);
                            bool target_FLAG = (PARAM_DBG_OverloadPCL_Target_ALL||PARAM_DBG_OverloadPCL_Target_HandsNonOccl);

                            bool OverloadPCL_ALL_FLAG          = PARAM_DBG_OverloadPCL_Source_ALL          || PARAM_DBG_OverloadPCL_Target_ALL;
                            bool OverloadPCL_HandsNonOccl_FLAG = PARAM_DBG_OverloadPCL_Source_HandsNonOccl || PARAM_DBG_OverloadPCL_Target_HandsNonOccl;

                            pcl::PointCloud<TYPE_Point_Sensor>::Ptr source_OVERLOAG_cloud_ORGan_P_( new pcl::PointCloud<TYPE_Point_Sensor> );
                            pcl::PointCloud<TYPE_Point_Sensor>::Ptr target_OVERLOAG_cloud_ORGan_P_( new pcl::PointCloud<TYPE_Point_Sensor> );

                            std::string                                     fileName_source;
                            std::string                                     fileName_target;
                            if        (OverloadPCL_ALL_FLAG)            {   fileName_source =  QString(   INPUT_PATH.left(INPUT_PATH.size()-1) + "_____ALL/"          + "pcl/" + QString::number( sourceID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd"   ).toStdString();
                                                                            fileName_target =  QString(   INPUT_PATH.left(INPUT_PATH.size()-1) + "_____ALL/"          + "pcl/" + QString::number( targetID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd"   ).toStdString();
                            } else if (OverloadPCL_HandsNonOccl_FLAG)   {   fileName_source =  QString(   INPUT_PATH.left(INPUT_PATH.size()-1) + "_____HandsNonOccl/" + "pcl/" + QString::number( sourceID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd"   ).toStdString();
                                                                            fileName_target =  QString(   INPUT_PATH.left(INPUT_PATH.size()-1) + "_____HandsNonOccl/" + "pcl/" + QString::number( targetID_fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd"   ).toStdString();
                            }

                            if (source_FLAG)   {   pcl::io::loadPCDFile<TYPE_Point_Sensor>( fileName_source, *source_OVERLOAG_cloud_ORGan_P_ );   pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_Sensor>visColor_OVERLOAG_1( source_OVERLOAG_cloud_ORGan_P_ );   viewer->addPointCloud<TYPE_Point_Sensor>(source_OVERLOAG_cloud_ORGan_P_,visColor_OVERLOAG_1,"cloud_OVERLOAD_1");   viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,"cloud_OVERLOAD_1");   }
                            if (target_FLAG)   {   pcl::io::loadPCDFile<TYPE_Point_Sensor>( fileName_target, *target_OVERLOAG_cloud_ORGan_P_ );   pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_Sensor>visColor_OVERLOAG_2( target_OVERLOAG_cloud_ORGan_P_ );   viewer->addPointCloud<TYPE_Point_Sensor>(target_OVERLOAG_cloud_ORGan_P_,visColor_OVERLOAG_2,"cloud_OVERLOAD_2");   viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,"cloud_OVERLOAD_2");   }

                    }
                    {
                        if (PARAM_DBG_RenderMesh_Source)     renderer->renderMeshes_2_PCL( viewer, 0, PARAM_DBG_RenderMesh_Source__Hands, PARAM_DBG_RenderMesh_Source__Object, PARAM_DBG_RenderMesh_Source__Normals );
                        if (PARAM_DBG_RenderMesh_Target)     renderer->renderMeshes_2_PCL( viewer, 1, PARAM_DBG_RenderMesh_Target__Hands, PARAM_DBG_RenderMesh_Target__Object, PARAM_DBG_RenderMesh_Target__Normals );
                    }


                    if (PARAM_DBG_RenderCORR_Skin)
                    {

                        if (PARAM_DBG_RenderCORR_Obj_Feat2d || PARAM_DBG_RenderCORR_Obj_Feat3d)
                        {
                            RRR = 0;
                            GGG = 0;
                            BBB = 1;
                        }
                        else
                        {
                            RRR = rand()/(float)RAND_MAX;
                            GGG = rand()/(float)RAND_MAX;
                            BBB = rand()/(float)RAND_MAX;
                        }

                        for (int mmm=0; mmm<corrFUSED_Filt->size(); mmm++)
                        {

                                //////////////////////////////////////////////////////////////////////////////
                                int                           labelINDEX = (*corrFUSED_Filt)[mmm].index_query;
                                //////////////////////////////////////////////////////////////////////////////
                                if (corrFUSED_NonFilt_labels[ labelINDEX ].label_ID != 1)            continue;
                                //////////////////////////////////////////////////////////////////////////////

                                TYPE_Point_KEYpt ptSource = source_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_query ];
                                TYPE_Point_KEYpt ptTarget = target_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_match ];

                                viewer->addLine( ptSource,
                                                 ptTarget, RRR,
                                                           GGG,
                                                           BBB, QString(QString("corrLine_Touch_")+QString::number(mmm)).toStdString() );
                        }
                    }


                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                    if (PARAM_DBG_RenderCORR_Skin_TouchVertSphere)
                    {
                        RRR = 0;
                        GGG = 0;
                        BBB = 1;

                        for (int mmm=0; mmm<corrFUSED_Filt->size(); mmm++)
                        {
                                //////////////////////////////////////////////////////////////////////////////
                                int                           labelINDEX = (*corrFUSED_Filt)[mmm].index_query;
                                //////////////////////////////////////////////////////////////////////////////
                                if (corrFUSED_NonFilt_labels[ labelINDEX ].label_ID != 1)            continue;
                                //////////////////////////////////////////////////////////////////////////////

                                TYPE_Point_KEYpt ptSource = source_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_query ];
                                TYPE_Point_KEYpt ptTarget = target_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_match ];

                                viewer->addSphere( ptSource, PARAM_DBG_RenderCORR_Skin_TouchVertSphereSiz, RRR,GGG,BBB, QString(QString("touchingVertexSource_")+QString::number(mmm)).toStdString() );
                                viewer->addSphere( ptTarget, PARAM_DBG_RenderCORR_Skin_TouchVertSphereSiz, RRR,GGG,BBB, QString(QString("touchingVertexTarget_")+QString::number(mmm)).toStdString() );
                        }
                    }


                    ////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////


                    if (PARAM_DBG_RenderPrimitive_Source)    viewer->addSphere( source_Sphere_Coeff_XYZR.center_PointXYZ, source_Sphere_Coeff_XYZR.radius, 153/255.0, 77/255.0, 255/255.0, "primitiveSource" );
                    if (PARAM_DBG_RenderPrimitive_Target)    viewer->addSphere( target_Sphere_Coeff_XYZR.center_PointXYZ, target_Sphere_Coeff_XYZR.radius, 153/255.0, 77/255.0, 255/255.0, "primitiveTarget" );


            } // if (applyHANDs && TEST_MODE)


            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (TEST_MODE)
            {

                    if (PARAM_DBG_RenderCORR_Obj_Feat2d)
                    {

                        for (int mmm=0; mmm<corrFUSED_Filt->size(); mmm++)
                        {
                                //////////////////////////////////////////////////////////////////////////////
                                int                           labelINDEX = (*corrFUSED_Filt)[mmm].index_query;
                                //////////////////////////////////////////////////////////////////////////////
                                if (corrFUSED_NonFilt_labels[ labelINDEX ].label_ID != 2)            continue;
                                //////////////////////////////////////////////////////////////////////////////

                                if (PARAM_DBG_RenderCORR_Obj_Feat3d || PARAM_DBG_RenderCORR_Skin)
                                {
                                    RRR = 1;
                                    GGG = 0;
                                    BBB = 0;
                                }
                                else
                                {
                                    RRR = rand()/(float)RAND_MAX;
                                    GGG = rand()/(float)RAND_MAX;
                                    BBB = rand()/(float)RAND_MAX;
                                }

                                TYPE_Point_KEYpt ptSource = source_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_query ];
                                TYPE_Point_KEYpt ptTarget = target_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_match ];

                                                                    viewer->addLine(   ptSource,
                                                                                       ptTarget, RRR,
                                                                                                 GGG,
                                                                                                 BBB,   QString(QString("FUSEDcorrLine_Texture_")+QString::number(mmm)).toStdString() );

                                if (PARAM_DBG_OBJ_FEAT_2D_Source)   viewer->addSphere( ptSource, PARAM_DBG_RenderCORR_Skin_TouchVertSphereSiz, RRR,GGG,BBB, QString(QString("FUSEDtexture3DptSource_")+QString::number(mmm)).toStdString() );
                                if (PARAM_DBG_OBJ_FEAT_2D_Target)   viewer->addSphere( ptTarget, PARAM_DBG_RenderCORR_Skin_TouchVertSphereSiz, RRR,GGG,BBB, QString(QString("FUSEDtexture3DptTarget_")+QString::number(mmm)).toStdString() );
                        }

                    }


            } // if (TEST_MODE)


            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (TEST_MODE)
            {

                    if (PARAM_DBG_RenderCORR_Obj_Feat3d)
                    {

                            if (PARAM_DBG_RenderCORR_Obj_Feat2d || PARAM_DBG_RenderCORR_Skin)
                            {

                                    for (int mmm=0; mmm<corrFUSED_Filt->size(); mmm++)
                                    {
                                            //////////////////////////////////////////////////////////////////////////////
                                            int                           labelINDEX = (*corrFUSED_Filt)[mmm].index_query;
                                            //////////////////////////////////////////////////////////////////////////////
                                            if (corrFUSED_NonFilt_labels[ labelINDEX ].label_ID != 3)            continue;
                                            //////////////////////////////////////////////////////////////////////////////

                                            float RRR = 0;
                                            float GGG = 1;
                                            float BBB = 0;

                                            TYPE_Point_KEYpt ptSource = source_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_query ];
                                            TYPE_Point_KEYpt ptTarget = target_cloud_KEYfused->points[ (*corrFUSED_Filt)[mmm].index_match ];

                                            viewer->addLine(   ptSource,
                                                               ptTarget, RRR,
                                                                         GGG,
                                                                         BBB, QString(QString("FUSEDcorrLine_Obj_")+QString::number(mmm)).toStdString()   );

                                            if (PARAM_DBG_OBJ_FEAT_3D_Source)   viewer->addSphere( ptSource, PARAM_DBG_RenderCORR_Skin_TouchVertSphereSiz, RRR,GGG,BBB, QString(QString("FUSEDobjFeat3DptSource_")+QString::number(mmm)).toStdString() );
                                            if (PARAM_DBG_OBJ_FEAT_3D_Target)   viewer->addSphere( ptTarget, PARAM_DBG_RenderCORR_Skin_TouchVertSphereSiz, RRR,GGG,BBB, QString(QString("FUSEDobjFeat3DptTarget_")+QString::number(mmm)).toStdString() );
                                    }

                            }

                    }

            }

    }



    if (TEST_MODE && PARAM_DBG_Render_PASS_FILTER)
    {
            viewer->addSphere( pcl::PointXYZ(PARAM_PASS_FILTER_XXX_min,0,(PARAM_PASS_FILTER_ZZZ_min+PARAM_PASS_FILTER_ZZZ_max)/2), PARAM_PASS_FILTER_Sph_SIZ, 1,0,0, "PASS_XXX_min" );
            viewer->addSphere( pcl::PointXYZ(PARAM_PASS_FILTER_XXX_max,0,(PARAM_PASS_FILTER_ZZZ_min+PARAM_PASS_FILTER_ZZZ_max)/2), PARAM_PASS_FILTER_Sph_SIZ, 0,1,0, "PASS_XXX_max" );
            viewer->addSphere( pcl::PointXYZ(0,PARAM_PASS_FILTER_YYY_min,(PARAM_PASS_FILTER_ZZZ_min+PARAM_PASS_FILTER_ZZZ_max)/2), PARAM_PASS_FILTER_Sph_SIZ, 1,0,0, "PASS_YYY_min" );
            viewer->addSphere( pcl::PointXYZ(0,PARAM_PASS_FILTER_YYY_max,(PARAM_PASS_FILTER_ZZZ_min+PARAM_PASS_FILTER_ZZZ_max)/2), PARAM_PASS_FILTER_Sph_SIZ, 0,1,0, "PASS_YYY_max" );
            viewer->addSphere( pcl::PointXYZ(0,0,PARAM_PASS_FILTER_ZZZ_min),                                                       PARAM_PASS_FILTER_Sph_SIZ, 1,0,0, "PASS_ZZZ_min" );
            viewer->addSphere( pcl::PointXYZ(0,0,PARAM_PASS_FILTER_ZZZ_max),                                                       PARAM_PASS_FILTER_Sph_SIZ, 0,1,0, "PASS_ZZZ_max" );

            pcl::PointXYZ p1(PARAM_PASS_FILTER_XXX_min,PARAM_PASS_FILTER_YYY_min,PARAM_PASS_FILTER_ZZZ_min);
            pcl::PointXYZ p2(PARAM_PASS_FILTER_XXX_min,PARAM_PASS_FILTER_YYY_min,PARAM_PASS_FILTER_ZZZ_max);
            ////////////////////////////////////////////////////////////////////////////////////////////////
            pcl::PointXYZ p3(PARAM_PASS_FILTER_XXX_min,PARAM_PASS_FILTER_YYY_max,PARAM_PASS_FILTER_ZZZ_min);
            pcl::PointXYZ p4(PARAM_PASS_FILTER_XXX_min,PARAM_PASS_FILTER_YYY_max,PARAM_PASS_FILTER_ZZZ_max);
            ////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////
            pcl::PointXYZ p5(PARAM_PASS_FILTER_XXX_max,PARAM_PASS_FILTER_YYY_min,PARAM_PASS_FILTER_ZZZ_min);
            pcl::PointXYZ p6(PARAM_PASS_FILTER_XXX_max,PARAM_PASS_FILTER_YYY_min,PARAM_PASS_FILTER_ZZZ_max);
            ////////////////////////////////////////////////////////////////////////////////////////////////
            pcl::PointXYZ p7(PARAM_PASS_FILTER_XXX_max,PARAM_PASS_FILTER_YYY_max,PARAM_PASS_FILTER_ZZZ_min);
            pcl::PointXYZ p8(PARAM_PASS_FILTER_XXX_max,PARAM_PASS_FILTER_YYY_max,PARAM_PASS_FILTER_ZZZ_max);

            viewer->addSphere( p1, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p1" );
            viewer->addSphere( p2, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p2" );
            viewer->addSphere( p3, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p3" );
            viewer->addSphere( p4, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p4" );

            viewer->addSphere( p5, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p5" );
            viewer->addSphere( p6, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p6" );
            viewer->addSphere( p7, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p7" );
            viewer->addSphere( p8, PARAM_PASS_FILTER_Sph_SIZ, 1,1,1, "PASS_p8" );


            viewer->addLine( p1,p2, 1,1,1, "passLine01" );  // 12 34
            viewer->addLine( p1,p3, 1,1,1, "passLine02" );
            viewer->addLine( p1,p4, 1,1,1, "passLine03" );
            viewer->addLine( p2,p3, 1,1,1, "passLine04" );
            viewer->addLine( p2,p4, 1,1,1, "passLine05" );
            viewer->addLine( p3,p4, 1,1,1, "passLine06" );

            viewer->addLine( p5,p6, 1,1,1, "passLine07" );  // 56 78
            viewer->addLine( p5,p7, 1,1,1, "passLine08" );
            viewer->addLine( p5,p8, 1,1,1, "passLine09" );
            viewer->addLine( p6,p7, 1,1,1, "passLine10" );
            viewer->addLine( p6,p8, 1,1,1, "passLine11" );
            viewer->addLine( p7,p8, 1,1,1, "passLine12" );

            viewer->addLine( p1,p2, 1,1,1, "passLine13" );  // 12 56
            viewer->addLine( p1,p5, 1,1,1, "passLine14" );
            viewer->addLine( p1,p6, 1,1,1, "passLine15" );
            viewer->addLine( p2,p5, 1,1,1, "passLine16" );
            viewer->addLine( p2,p6, 1,1,1, "passLine17" );
            viewer->addLine( p5,p6, 1,1,1, "passLine18" );

            viewer->addLine( p3,p4, 1,1,1, "passLine19" );  // 34 78
            viewer->addLine( p3,p7, 1,1,1, "passLine20" );
            viewer->addLine( p3,p8, 1,1,1, "passLine21" );
            viewer->addLine( p4,p7, 1,1,1, "passLine22" );
            viewer->addLine( p4,p8, 1,1,1, "passLine23" );
            viewer->addLine( p7,p8, 1,1,1, "passLine24" );

            viewer->addLine( p1,p3, 1,1,1, "passLine25" );  // 13 27
            viewer->addLine( p1,p5, 1,1,1, "passLine26" );
            viewer->addLine( p1,p7, 1,1,1, "passLine27" );
            viewer->addLine( p3,p5, 1,1,1, "passLine28" );
            viewer->addLine( p3,p7, 1,1,1, "passLine29" );
            viewer->addLine( p5,p7, 1,1,1, "passLine30" );

            viewer->addLine( p2,p4, 1,1,1, "passLine31" );  // 24 68
            viewer->addLine( p2,p6, 1,1,1, "passLine32" );
            viewer->addLine( p2,p8, 1,1,1, "passLine33" );
            viewer->addLine( p4,p6, 1,1,1, "passLine34" );
            viewer->addLine( p4,p8, 1,1,1, "passLine35" );
            viewer->addLine( p6,p8, 1,1,1, "passLine36" );
    }



    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    std::vector<int>                                                                                 dummyIndicesNAN;
    pcl::removeNaNFromPointCloud(        *accumAlignedClouds_UNorg_PN, *accumAlignedClouds_UNorg_PN, dummyIndicesNAN);
    pcl::removeNaNNormalsFromPointCloud( *accumAlignedClouds_UNorg_PN, *accumAlignedClouds_UNorg_PN, dummyIndicesNAN);


    pathSave = OUTPUT_PATH + "___OUT___1___pairwiseAlignment_PCL.pcd";   if (TEST_MODE == false)  pcl::io::savePCDFile(pathSave.toStdString(),*accumAlignedClouds_UNorg_PN,true);


    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////

    ///////////////////////
    if (TEST_MODE == false)
    {  ////////////////////

                //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  PCLVisualizer - addPointCloud FIN" << std::endl;
                viewer->removeAllPointClouds();
                viewer->removeAllShapes();
                pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_PostPr>visColorSource( accumAlignedClouds_UNorg_PN);
                viewer->addPointCloud<TYPE_Point_PostPr>(                                            accumAlignedClouds_UNorg_PN, visColorSource, "accumAlignedClouds_UNorg_PN" );
                viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,                                         "accumAlignedClouds_UNorg_PN" );
                //////////////////////
                viewer->resetCamera();
                viewer->spinOnce();
                //////////////////////
    }

    PARAM_VOXELFILTER_leafSize /= (double)NUMBBB;
    PARAM_VOXELFILTER_leafSize *= PARAM_VOXELFILTER_leafSizeCOEFF;
    my_Filtering_Voxelgrid( accumAlignedClouds_UNorg_PN );
    std::cout << std::endl << "VoxelGrid - downsample AccumResult" << std::endl;

    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////


    pathSave = OUTPUT_PATH + "___OUT___1___pairwiseAlignment_PCL_VoxelGrid.pcd";   if (TEST_MODE == false)  pcl::io::savePCDFile(pathSave.toStdString(),*accumAlignedClouds_UNorg_PN,true);


    std::cout << std::endl << std::endl;
    //std::cout << "///////////////////////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    //std::cout << "///////////////////////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    //std::cout << "///////////////////////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    //std::cout << "///////////////////////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    //std::cout << "///////////////////////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;


    std::cout << std::endl << std::endl << std::endl << "Saved FINAL Accumulated/Aligned Cloud - PCD/PLY - dense = " << accumAlignedClouds_UNorg_PN->is_dense << std::endl << std::endl << std::endl;


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    if (PARAM_DBG_RenderObj_Source)    {   pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_PostPr>visColor_1( source_cloud_UNorg_PN );  viewer->addPointCloud<TYPE_Point_PostPr>(source_cloud_UNorg_PN,visColor_1,"cloud_ini_1");    viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,"cloud_ini_1");     }
    if (PARAM_DBG_RenderObj_Target)    {   pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_PostPr>visColor_2( target_cloud_UNorg_PN );  viewer->addPointCloud<TYPE_Point_PostPr>(target_cloud_UNorg_PN,visColor_2,"cloud_ini_2");    viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,"cloud_ini_2");     }

    if (PARAM_DBG_RenderObj_Source && PARAM_DBG_RenderObjNORMALS_Source)    viewer->addPointCloudNormals<TYPE_Point_PostPr,TYPE_Point_PostPr>(source_cloud_UNorg_PN, source_cloud_UNorg_PN, PARAM_DBG_Normals_VizDistCOEFF, PARAM_DBG_Normals_VizSizeCOEFF, "normals_finputt"); // level // scale
    if (PARAM_DBG_RenderObj_Target && PARAM_DBG_RenderObjNORMALS_Target)    viewer->addPointCloudNormals<TYPE_Point_PostPr,TYPE_Point_PostPr>(target_cloud_UNorg_PN, target_cloud_UNorg_PN, PARAM_DBG_Normals_VizDistCOEFF, PARAM_DBG_Normals_VizSizeCOEFF, "normals_ftarget"); // level // scale


    for (int touchProblemID=0; touchProblemID<framesTouchProblem.size(); touchProblemID++)
    {
        std::cout << "framesTouchProblem["<<touchProblemID<<"] = " << framesTouchProblem[ touchProblemID ] << std::endl;
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    if (PARAM_RUN__ONLY__TOUCH__TRANSF)  std::cout << "\n\n" << "---------------->  " << "PARAM_RUN__ONLY__TOUCH__TRANSF = trueeeeeeeeee !!!" << "\n" << std::endl;


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    std::cout << "\n\n" << "hoho !!!!!!!!!!!!!!!" << "\n" << std::endl;

    //////////////////////
    viewer->resetCamera();
    viewer->spinOnce();
    //////////////////////

    if (VIEW_ENABLED == true)
    {
        while (!viewer->wasStopped())
        {
            viewer->spinOnce();
            boost::this_thread::sleep(boost::posix_time::microseconds(100000));
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    std::cout << std::endl << "DONE !!!!!" << std::endl << std::endl;



}




QString Registrator::getOnly_fileNameWithExtension( QString FULL_PATH )
{
    QStringList myStringList = FULL_PATH.split(QRegExp("/"), QString::SkipEmptyParts);

    QString fileNameWithExtension = myStringList.at( myStringList.length()-1 );
    //////////////////////////////
    return  fileNameWithExtension;
    //////////////////////////////
}




void Registrator::resolution_bilateral_normals_outlierRemoval_passthrough_KEEP_ORG(
                                                                                        pcl::PointCloud<TYPE_Point_Sensor>::Ptr &source_cloud_ORGan_P_,
                                                                                        pcl::PointCloud<TYPE_Point_Sensor>::Ptr &target_cloud_ORGan_P_,
                                                                                        pcl::PointCloud<TYPE_Point_PostPr>::Ptr &source_cloud_UNorg_PN,
                                                                                        pcl::PointCloud<TYPE_Point_PostPr>::Ptr &target_cloud_UNorg_PN,
                                                                                        double                                  &model_resolution_Source,
                                                                                        double                                  &model_resolution_Target,
                                                                                        const bool                              &TEST_MODE
                                                                                  )
{


                  resolution_bilateral_normals_outlierRemoval_passthrough_KEEP_ORG(   source_cloud_ORGan_P_,
                                                                                      source_cloud_UNorg_PN,
                                                                                      model_resolution_Source,
                                                                                      TEST_MODE );

                  resolution_bilateral_normals_outlierRemoval_passthrough_KEEP_ORG(   target_cloud_ORGan_P_,
                                                                                      target_cloud_UNorg_PN,
                                                                                      model_resolution_Target,
                                                                                      TEST_MODE );

}


void Registrator::resolution_bilateral_normals_outlierRemoval_passthrough_KEEP_ORG(
                                                                                        pcl::PointCloud<TYPE_Point_Sensor>::Ptr &cloud_ORGan_P_,
                                                                                        pcl::PointCloud<TYPE_Point_PostPr>::Ptr &cloud_UNorg_PN,
                                                                                        double                                  &model_resolution,
                                                                                        const bool                              &TEST_MODE

                                                                                  )
{



        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Resolution
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        model_resolution = static_cast<double>(  computeCloudResolution( cloud_ORGan_P_ )  );


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        BILATERAL Filtering
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        if     (syntheticORrealistic.contains("realistic") && PARAM_KILL_BILATERAL==false)
        {
                //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  Bilateral Filtering" << std::endl;

                my_Bilateral_Filtering( cloud_ORGan_P_, model_resolution );
        }


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        NORMAL ESTIMATION   (later - Clean NAN Normals)
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  Normal Estimation || " << PARAM_NORMAL_NormalSmoothingSize << std::endl << std::endl;


        my_Normal_Estimator( cloud_ORGan_P_, cloud_UNorg_PN, syntheticORrealistic, false );

        //////////////////////////////////////////
        // cloud_UNorg_PN is still ORG here !!! //
        //////////////////////////////////////////


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        OUTLIER REMOVAL
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        //////////////////////////////////////////
        // cloud_UNorg_PN is still ORG here !!! //
        //////////////////////////////////////////


        if (syntheticORrealistic.contains("realistic") && PARAM_KILL_SOR==false)
        {

                //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  SOR " << std::endl << std::endl;

                                                                                                                                for (int ppp=0; ppp<cloud_UNorg_PN->points.size(); ppp++) // combats "is not from a projective device"
                                                                                                                                {
                                                                                                                                    cloud_UNorg_PN->points[ppp].x /= 1000;
                                                                                                                                    cloud_UNorg_PN->points[ppp].y /= 1000;
                                                                                                                                    cloud_UNorg_PN->points[ppp].z /= 1000;
                                                                                                                                }

                pcl::StatisticalOutlierRemoval<TYPE_Point_PostPr>   sor;
                                                                    sor.setMeanK(           PARAM_SOR_MeanK           );
                                                                    sor.setStddevMulThresh( PARAM_SOR_StddevMulThresh );
                                                                    sor.setKeepOrganized( true );
                                                                    sor.setInputCloud(      cloud_UNorg_PN     );
                                                                    sor.filter(            *cloud_UNorg_PN     );

                                                                                                                                for (int ppp=0; ppp<cloud_UNorg_PN->points.size(); ppp++)
                                                                                                                                {
                                                                                                                                    cloud_UNorg_PN->points[ppp].x *= 1000;
                                                                                                                                    cloud_UNorg_PN->points[ppp].y *= 1000;
                                                                                                                                    cloud_UNorg_PN->points[ppp].z *= 1000;
                                                                                                                                }
        }


        if (syntheticORrealistic.contains("realistic") && PARAM_KILL_PASS==false  && TEST_MODE==false)
        {

                //std::cout << std::endl << "////////////////////////////////////////////////////////////////////  PassThrough " << std::endl << std::endl;

                // Create the filtering object
                pcl::PassThrough<TYPE_Point_PostPr>                 pass;
                                                                    pass.setFilterFieldName( "z" );
                                                                    pass.setFilterLimits( PARAM_PASS_FILTER_ZZZ_min, PARAM_PASS_FILTER_ZZZ_max );
                                                                    pass.setKeepOrganized( true );
                                                                    pass.setInputCloud(  cloud_UNorg_PN);
                                                                    pass.filter(        *cloud_UNorg_PN);
                                                                    /////////////////////////////////////
                                                                    pass.setFilterFieldName( "y" );
                                                                    pass.setFilterLimits( PARAM_PASS_FILTER_YYY_min, PARAM_PASS_FILTER_YYY_max );
                                                                    pass.setKeepOrganized( true );
                                                                    pass.setInputCloud(  cloud_UNorg_PN);
                                                                    pass.filter(        *cloud_UNorg_PN);
                                                                    /////////////////////////////////////
                                                                    pass.setFilterFieldName( "x" );
                                                                    pass.setFilterLimits( PARAM_PASS_FILTER_XXX_min, PARAM_PASS_FILTER_XXX_max );
                                                                    pass.setKeepOrganized( true );
                                                                    pass.setInputCloud(  cloud_UNorg_PN);
                                                                    pass.filter(        *cloud_UNorg_PN);
                                                                    /////////////////////////////////////
        }

}


